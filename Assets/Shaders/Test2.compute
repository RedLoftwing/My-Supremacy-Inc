// VertexAdjustComputeShader.compute

#pragma kernel CSMain

// Buffer of vertices to be processed
StructuredBuffer<float3> vertices;
// Buffer of original vertex positions
StructuredBuffer<float3> originalVertexPos;
// Buffer to store the current y-offset for each vertex
RWStructuredBuffer<float> vertexYOffset;
// Output buffer for modified vertices
RWStructuredBuffer<float3> outputVertices;

// Parameters
float3 intersectingObjectPosition;
float3 objectSize;
float intersectionSpeed;
float deltaTime;

[numthreads(1, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Read the vertex position
    float3 vertex = vertices[id.x];
    float3 originalVertex = originalVertexPos[id.x];

    // Define the bounds
    float3 halfSize = objectSize / 2;
    float3 objectPositionCentre = intersectingObjectPosition + halfSize;
    float3 minBounds = objectPositionCentre - halfSize;
    float3 maxBounds = objectPositionCentre + halfSize;

    // Check if the vertex is within the bounds
    bool isWithinBounds = vertex.x >= minBounds.x && vertex.x <= maxBounds.x &&
                          vertex.y >= minBounds.y && vertex.y <= maxBounds.y &&
                          vertex.z >= minBounds.z && vertex.z <= maxBounds.z;

    // Get the current y-offset for the vertex
    float currentYOffset = vertexYOffset[id.x];

    if (isWithinBounds)
    {
        // Increment the y-offset if within bounds
        currentYOffset += intersectionSpeed * deltaTime;
    }
    else
    {
        // Gradually return to original y-position if not intersecting
        currentYOffset = lerp(currentYOffset, 0.0, deltaTime);
    }

    // Update the y-offset buffer
    vertexYOffset[id.x] = currentYOffset;

    // Apply the y-offset to the vertex position
    vertex.y = originalVertex.y + currentYOffset;

    // Write the modified vertex position to the output buffer
    outputVertices[id.x] = vertex;
}